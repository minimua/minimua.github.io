---
title: "MySQL索引"
date: 2023-07-10T22:00:00+08:00
tags: ["tech"]
categories: ["tech"]
---

## InnoDB索引与MyISAM索引实现的区别是什么？

### 1. **聚簇索引（Clustered Index） vs 非聚簇索引（Non-clustered Index）**

- **InnoDB**：  
  - InnoDB 使用 **聚簇索引**。这意味着表的数据和主键索引存储在一起，主键索引的叶子节点直接存储行记录的完整数据。
  - 每个表按主键顺序存储，因此通过主键查询时，InnoDB 可以非常快速地定位到行数据。
  - 如果表没有主键，InnoDB 会选择一个唯一的非空索引作为聚簇索引。如果没有这样的索引，InnoDB 会隐式创建一个 rowid 作为聚簇索引。
  
- **MyISAM**：  
  - MyISAM 使用 **非聚簇索引**，主键和其他索引都是独立的。主键索引的叶子节点存储的是指向数据文件的地址（指针），而不是行数据本身。
  - 因此，通过索引查找到主键后，还需要通过指针去数据文件中查找具体的数据，导致数据访问相对较慢。
  - MyISAM 的数据文件和索引文件是分开的，索引文件只包含指向数据记录的指针。

### 2. **主键索引的区别**

- **InnoDB**：  
  - 主键索引是聚簇索引，数据存储和索引结构紧密耦合在一起。通过主键查询数据非常高效，因为直接从聚簇索引中就能读取到完整的数据。
  - 由于每个表只能有一个聚簇索引，因此在设计表结构时，合理选择主键非常重要。

- **MyISAM**：  
  - 主键索引是非聚簇索引，数据和索引是分开的。索引中存储的只是指向数据文件的指针，因此查询时需要先从索引找到指针，再根据指针去数据文件中读取数据。

### 3. **二级索引的区别**

- **InnoDB**：  
  - InnoDB 的二级索引（非主键索引）的叶子节点存储的是主键值，而不是行数据的物理地址。这意味着通过二级索引查询时，InnoDB 需要先通过二级索引找到主键，再通过主键去聚簇索引中定位行数据。
  - 这种设计的好处是，如果表的行数据移动了（比如由于行更新或重建表），不需要更新二级索引中的记录，因为二级索引只依赖主键，而不依赖数据的物理存储位置。

- **MyISAM**：  
  - MyISAM 的二级索引存储的是数据行的物理地址（文件中的偏移量）。通过二级索引查询时，直接通过存储的物理地址访问数据，而无需再通过主键查找。
  - 但如果表的数据文件发生了碎片化或者表被重新组织，这些物理地址可能会变动，二级索引需要重新构建。

### 4. **数据存储和索引维护的差异**

- **InnoDB**：  
  - InnoDB 的数据存储和索引维护更加复杂，因为 InnoDB 需要维护聚簇索引的结构。同时，二级索引依赖于主键，因此如果主键发生变动，二级索引也需要调整。
  - InnoDB 的存储文件中会有额外的元数据来维护事务、锁等功能，索引文件也可能稍大。
  
- **MyISAM**：  
  - MyISAM 的索引实现更简单，索引和数据是分离的。索引的叶子节点存储的是指向数据的物理地址，这使得索引文件较小，但当表的数据发生变化时，索引的维护成本可能较高。

### 5. **事务支持**

- **InnoDB**：  
  - InnoDB 支持事务（ACID），因此索引的实现也会与事务有关，比如需要考虑锁机制、事务回滚等。InnoDB 中的索引操作会受到事务隔离级别和锁机制的影响，这在多用户并发场景下尤为重要。
  
- **MyISAM**：  
  - MyISAM 不支持事务，因此在索引的实现上不需要考虑事务的复杂性。它的索引操作简单且没有锁机制的开销，但在数据安全和一致性方面不如 InnoDB。

### 6. **外键支持**

- **InnoDB**：  
  - InnoDB 支持外键约束。外键的存在会影响到索引的创建和维护，因为外键约束要求索引能够快速查找相关的主键或唯一键。
  
- **MyISAM**：  
  - MyISAM 不支持外键约束，因此在设计表结构时不会受外键的限制。MyISAM 主要用于一些没有复杂关系的简单应用。

### 7. **性能和适用场景**

- **InnoDB**：  
  - 适合对 **事务**、**数据完整性** 要求较高的场景，特别是在存在大量 **写操作** 或并发操作时，InnoDB 的锁机制和事务支持显得尤为重要。索引的聚簇结构使主键查询速度很快，但二级索引的查询需要更多的步骤（先通过二级索引找主键，再通过主键找数据）。
  
- **MyISAM**：  
  - 适合 **读多写少** 的场景，因为 MyISAM 的索引是非聚簇的，读取时直接通过物理地址找到数据，查询速度很快。但由于不支持事务和外键约束，适用场景较为有限，通常用于对数据一致性要求不高的应用。

### 总结：
- **InnoDB**：使用聚簇索引，主键查询性能优越，支持事务、外键、行级锁，适合高并发和复杂的应用场景。
- **MyISAM**：使用非聚簇索引，索引结构简单，读取性能较好，但不支持事务和外键，适合以读为主的场景。



## B+树索引实现原理（数据结构）
**B+树索引**是 MySQL 数据库中广泛使用的一种索引结构，特别是在 InnoDB 存储引擎中。B+树索引通过树状结构存储数据，使得查询、插入、删除等操作都能高效进行。下面将介绍 B+树的基本结构及其实现原理。

### 1. **B+树的基本结构**
- **多路平衡搜索树**：B+树是一种平衡的多路搜索树，其每个节点可以有多个子节点。常见的 B+树是阶数为 `m` 的树，每个节点可以有最多 `m` 个子节点，且非叶子节点最多有 `m-1` 个键。
- **叶子节点存储数据**：B+树的叶子节点存储数据或数据的指针，所有的叶子节点通过指针串联在一起，形成一个链表，便于范围查询。
- **非叶子节点存储索引**：非叶子节点存储索引键，用来引导查询数据，但不存储实际的数据。这使得非叶子节点的大小更小，可以容纳更多的索引键。

### 2. **B+树的性质**
- **平衡性**：B+树是一种平衡树。树的高度是固定的，并且所有的数据都存储在叶子节点上，这意味着从根节点到任意一个叶子节点的路径长度相同。插入或删除数据时，树结构会保持平衡，避免了退化成链表的情况。
- **节点容量**：B+树的每个节点包含多个键值，通常与磁盘块的大小相匹配，这样可以在一次 I/O 操作中读取整个节点，减少磁盘读取次数，提升查询效率。
- **顺序性**：B+树的叶子节点按键值顺序排列，通过指针连接，方便范围查询或顺序扫描。

### 3. **B+树索引的实现原理**

#### (1) **索引存储**
B+树索引将表中的数据按一定的顺序存储，具体存储位置如下：
- **非叶子节点**：存储的是索引键值和指向下一级子节点的指针。这些键值只用于定位数据的范围，不存储实际的行数据。
- **叶子节点**：存储的是索引键值和实际的行数据，或存储行数据的指针（根据是否是聚簇索引）。

#### (2) **查询操作**
当进行查询操作时，B+树索引通过逐层搜索的方式来查找目标数据：
- **从根节点开始**：根据查询条件，定位到合适的键值范围，从而找到指向下一级节点的指针。
- **递归查找**：进入下一级节点，重复相同的操作，直至到达叶子节点。
- **叶子节点查找**：在叶子节点中找到与查询条件匹配的键值，并返回对应的行数据或指针。如果是范围查询，可以通过叶子节点之间的链表直接遍历。

#### (3) **插入操作**
插入数据时，B+树需要维护其平衡性和顺序性：
- **查找插入位置**：首先通过类似查询的方式，找到新键值应插入的叶子节点。
- **插入键值**：如果叶子节点有足够的空间，直接插入。如果叶子节点已满，则需要进行节点拆分，将键值平均分成两个节点。
- **节点拆分**：拆分后，需要将新节点的键值上移到父节点中。如果父节点也满了，继续向上拆分，直至树的平衡得到恢复。如果根节点发生拆分，树的高度会增加一层。

#### (4) **删除操作**
删除数据时，B+树同样需要维护平衡：
- **查找删除位置**：通过索引键找到需要删除的叶子节点。
- **删除键值**：删除键值后，如果叶子节点中的键值数量低于节点的最小容量（一般为一半），则需要进行合并或借位操作。
- **节点合并或借位**：如果兄弟节点有足够的键值，可以从兄弟节点“借”一个键值来维持平衡。如果兄弟节点也不足，则将当前节点与兄弟节点合并。合并可能导致父节点的键值减少，如果父节点也低于最小容量，继续向上处理，直到整棵树恢复平衡。

#### (5) **范围查询**
范围查询是 B+树的强项。由于叶子节点按顺序排列并通过指针连接，可以直接在叶子节点中顺序遍历，快速找到范围内的所有记录。这比普通的二叉树或哈希结构更加高效。

### 4. **B+树在 InnoDB 中的应用**

#### (1) **聚簇索引（Clustered Index）**
- 在 InnoDB 中，主键索引默认是聚簇索引。叶子节点存储的是完整的行数据，非叶子节点存储的是索引键。通过主键查询时，InnoDB 可以直接通过聚簇索引找到完整的数据。
- 如果没有显式定义主键，InnoDB 会选择一个唯一的非空索引作为聚簇索引；如果没有唯一索引，InnoDB 会隐式创建一个 rowid 作为聚簇索引。

#### (2) **二级索引（Secondary Index）**
- 非主键索引在 InnoDB 中称为二级索引，叶子节点存储的是主键值而不是行数据。当通过二级索引查询时，InnoDB 需要先通过二级索引找到主键值，再通过主键值回到聚簇索引查找完整数据。

### 5. **B+树的优势**

- **平衡性保证查询效率**：B+树总是保持平衡，确保查询、插入、删除的时间复杂度为 O(log N)，即使在数据量非常大时，也能保持较快的访问速度。
- **减少磁盘 I/O**：由于 B+树节点中的索引键较多，且一次 I/O 可以读取多个键值，大大减少了磁盘访问次数，提升了查询性能。
- **支持范围查询**：叶子节点按顺序排列并通过指针连接，能够非常高效地支持范围查询、排序查询等操作。
- **高效的插入、删除**：通过节点拆分和合并，B+树能够在插入和删除操作时保持平衡，并且由于其有序结构，不会像哈希表那样在插入时产生冲突或扩展。

### 总结：
B+树作为 MySQL 中索引的主要数据结构，通过平衡多路树的设计，有效保证了大数据量下的查询、插入、删除操作的高效性。其叶子节点顺序排列的特性，使得 B+树非常适合范围查询，这也是 MySQL 中选择 B+树作为索引结构的关键原因之一。

## MySQL索引数据结构选择的合理性

### 1. **B+树（B+ Tree）结构的合理性**：
MySQL 中的大多数索引（尤其是 InnoDB 的聚簇索引和二级索引）都采用 **B+树** 作为底层的数据结构，主要原因如下：

- **平衡性和稳定性**：B+树是一种自平衡的多路搜索树，所有叶子节点处于同一层。查询时树的高度保持相对稳定，使得查找、插入、删除的时间复杂度均为 O(log N)，确保数据库在大数据量下的查询性能不至于恶化。
  
- **节点存储更高效**：B+树的非叶子节点只存储索引键，叶子节点存储具体数据，非叶子节点只需占用较少的空间，从而可以在每个节点中存储更多的键。MySQL 每次从磁盘读取数据时按页读取，较大的节点可以减少 I/O 次数，提升性能。

- **范围查询性能好**：B+树的叶子节点通过指针顺序连接起来，非常适合范围查询。对于查询如 `BETWEEN` 或 `ORDER BY` 等，MySQL 可以利用叶子节点的顺序指针进行快速范围扫描，而不需要重新回到根节点，效率更高。

### 2. **为什么不使用哈希（Hash）作为索引**：
虽然哈希结构具有常量级的查找效率，但 MySQL 没有选择哈希结构作为默认索引类型，原因包括：

- **无法支持范围查询**：哈希索引只能用于精确匹配查询，无法用于范围查询（如 `BETWEEN`、`<`、`>` 等）。这在很多业务场景中不适用，而 B+树支持非常高效的范围查询。

- **无序性**：哈希索引将数据打散，失去了原有的顺序，因此对于排序操作的支持较差。而 B+树中的叶子节点是有序的，能够有效支持排序查询。

- **哈希冲突**：哈希索引可能会产生哈希冲突，尤其是在数据量增大时，冲突频率可能增加，导致性能下降。相比之下，B+树通过其结构保持数据有序和分散，避免了这类问题。

### 3. **为什么不选择红黑树等其他平衡树**：
- **红黑树效率较低**：红黑树虽然也是一种平衡树，但由于每个节点只存储一个键值，树的高度较高，相对 B+树来说查询和插入效率较低。
  
- **磁盘 I/O 问题**：数据库操作往往涉及磁盘 I/O，红黑树的节点相对较小，需要更频繁的磁盘访问。而 B+树节点较大，能够充分利用每次 I/O 读取的磁盘页，减少访问磁盘的次数。

### 4. **为什么不使用 AVL 树**：
- **旋转频繁**：AVL 树是一种严格平衡的二叉树，插入和删除操作会频繁导致树的旋转，影响性能。B+树在高度平衡和写入性能之间做出了更好的权衡。

### 5. **InnoDB 引擎中的特殊优化**：
- **聚簇索引（Clustered Index）**：InnoDB 的聚簇索引利用了 B+树的特性，将表的数据行存储在叶子节点中，这样可以通过主键直接快速找到对应的数据行。非主键的查询则需要二次索引查找。
  
- **二级索引（Secondary Index）**：二级索引同样使用 B+树，但叶子节点存储的是主键值而不是数据行本身。当查询涉及非主键列时，首先通过二级索引找到主键，再通过聚簇索引获取完整数据。

### 6. **总结 MySQL 选择 B+树的原因**：
- **平衡性好**，查询性能稳定；
- **磁盘 I/O 效率高**，减少访问次数；
- **支持范围查询**，适用于广泛的业务场景；
- **支持排序操作**，满足多种复杂查询需求。

## 什么是索引下推

索引下推是 MySQL 5.6 引入的一种优化技术。它的作用是，当我们执行一个带有非索引列条件的查询时，MySQL 可以在存储引擎层面提前过滤掉不符合条件的记录，而不是等到从存储引擎返回完整的行数据后再进行过滤。这减少了回表查询的次数，提升了查询效率。  
举个例子：如果我们有一个复合索引 `category_id` 和 `price`，查询语句是 `WHERE category_id = 1 AND price > 100 AND name LIKE 'A%'`，启用索引下推后，MySQL 会在找到 `category_id` 和 `price` 满足条件的记录时，直接在存储引擎层过滤 `name LIKE 'A%'`，减少了回表操作。而没有索引下推的话，则需要对所有满足 `category_id` 和 `price` 的记录都回表查询 `name` 列。 索引下推的优点在于它显著减少了 I/O 操作，特别是在有大量记录需要查询时表现非常出色。


  ## 什么情况会导致索引失效

  - **没有遵循最左前缀法则**：对于复合索引，必须从最左边的列开始使用索引。
  - **在索引列上使用函数**：如果在查询条件中对索引列使用了函数或表达式，索引将失效。
  - **隐式类型转换**：查询条件中的类型与索引列的类型不一致时，MySQL 会进行隐式转换，导致索引失效。
  - **使用 `OR`**：当 `OR` 两侧的字段没有同时命中索引时，索引将无法生效。
  - **范围查询后索引失效**：在复合索引中，使用了范围查询（如 `<`、`>`）后面的索引列将无法被使用。
  - **`LIKE` 查询以 `%` 开头**：这种模糊查询会导致索引失效。
  - **索引选择性差**：当某个字段的索引选择性较差时，MySQL 可能放弃使用索引，进行全表扫描。
  - **数据量小**：如果表的数据量过小，MySQL 也可能会直接进行全表扫描。
